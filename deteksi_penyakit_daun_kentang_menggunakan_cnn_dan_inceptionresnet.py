# -*- coding: utf-8 -*-
"""Deteksi Penyakit Daun Kentang Menggunakan CNN dan InceptionResNet

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14TgIvnnWyE54EngJ58GwP17aRRne2fyT

Alexis Ronauli Manurung (2215061109)
> Untuk Tugas UTS Computer Vision

# Import Dataset From Kaggle
"""

import kagglehub
rizwan123456789_potato_disease_leaf_datasetpld_path = kagglehub.dataset_download('rizwan123456789/potato-disease-leaf-datasetpld')

print('Data source import complete.')

"""---
# Import Libraries
"""

import numpy as np
import pandas as pd
import os

import random
import matplotlib.pyplot as plt
import matplotlib.image as mpimg

import warnings
warnings.filterwarnings('ignore')

from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras.models import Model
from tensorflow.keras.layers import Input, Conv2D, MaxPooling2D, Flatten, Dense, GlobalAveragePooling2D

from tensorflow.keras.applications import InceptionResNetV2
from tensorflow.keras import layers

"""----------------------------

# Load Data
"""

# Paths
Early_Blight_path = '/kaggle/input/potato-disease-leaf-datasetpld/PLD_3_Classes_256/Training/Early_Blight'
Healthy_path = '/kaggle/input/potato-disease-leaf-datasetpld/PLD_3_Classes_256/Training/Healthy'
Late_Blight_path = '/kaggle/input/potato-disease-leaf-datasetpld/PLD_3_Classes_256/Training/Late_Blight'

# Function to get random images
def get_random_images(path, num_samples):
    image_files = [os.path.join(path, f) for f in os.listdir(path) if f.lower().endswith(('.png', '.jpg', '.jpeg'))]
    return random.sample(image_files, num_samples)

"""## Preview the Images"""

# Number of samples to display per class
num_samples = 3

# Get samples
early_images = get_random_images(Early_Blight_path, num_samples)
healthy_images = get_random_images(Healthy_path, num_samples)
late_images = get_random_images(Late_Blight_path, num_samples)

# Class labels and images
classes = ['Early Blight', 'Healthy', 'Late Blight']
all_images = [early_images, healthy_images, late_images]

# Plotting
fig, axes = plt.subplots(len(classes), num_samples, figsize=(num_samples * 5, 12))

for row, (class_name, images) in enumerate(zip(classes, all_images)):
    for col, image_path in enumerate(images):
        ax = axes[row, col] if num_samples > 1 else axes[row]
        img = mpimg.imread(image_path)
        ax.imshow(img)
        ax.set_title(class_name, fontsize=16)
        ax.axis('off')

plt.tight_layout()
plt.show()

"""## `iii` Shape"""

# Early Blight
img = mpimg.imread(early_images[0])
print(f"Early Blight : {img.shape}")

# Healthy
img = mpimg.imread(healthy_images[0])
print(f"Healthy : {img.shape}")

# Late Blight
img = mpimg.imread(late_images[0])
print(f"Late Blight : {img.shape}")

"""----------------

#  Preprocessing
"""

batch_size = 32

train_datagen = ImageDataGenerator(
    rotation_range=40,
    width_shift_range=0.2,
    height_shift_range=0.2,
    rescale=1./255,
    shear_range=0.2,
    zoom_range=0.2,
    horizontal_flip=True,
    fill_mode='nearest'
)

val_datagen = ImageDataGenerator(rescale=1./255)

# Only rescaling for test data
test_datagen = ImageDataGenerator(rescale=1./255)


train_generator = train_datagen.flow_from_directory(
    directory='/kaggle/input/potato-disease-leaf-datasetpld/PLD_3_Classes_256/Training',
    target_size=(256, 256),
    batch_size=batch_size,
    class_mode='categorical'
)

# this is a similar generator, for validation data
validation_generator = val_datagen.flow_from_directory(
        '/kaggle/input/potato-disease-leaf-datasetpld/PLD_3_Classes_256/Validation',
        target_size=(256, 256),
        batch_size=batch_size,
        class_mode='categorical'
        )

test_generator = test_datagen.flow_from_directory(
        '/kaggle/input/potato-disease-leaf-datasetpld/PLD_3_Classes_256/Testing',
        target_size=(256, 256),
        batch_size=batch_size,
        class_mode='categorical'
        )

"""----------------

# CNN Model

## Model Design
"""

# Define the input shape
inputs = Input((256, 256, 3))

# First Convolutional layer with ReLU activation and MaxPooling
x = Conv2D(32, (3, 3), activation='relu')(inputs)
x = MaxPooling2D()(x)

# Second Convolutional layer with ReLU activation and MaxPooling
x = Conv2D(64, (3, 3), activation='relu')(x)
x = MaxPooling2D()(x)

# Flatten the output from the convolutional layers
x = Flatten()(x)

# Fully connected Dense layer
x = Dense(64, activation='relu')(x)

# Output layer with sigmoid activation for binary classification
outputs = Dense(3, activation='softmax')(x)

# Create the model
model = Model(inputs, outputs)

# Display model summary
model.summary()

"""## Model Compilation & Training"""

model.compile(
    optimizer='adam',
    loss='categorical_crossentropy',
    metrics=['accuracy']
)

history = model.fit(
    train_generator,
    epochs=10,
    validation_data=validation_generator
)

"""## Model Evaluation"""

# Evaluate on training data
loss_train, accuracy_train = model.evaluate(train_generator)
print(f"Accuracy (Train): {accuracy_train:.4%}")

# Evaluate on validation data
loss_val, accuracy_val = model.evaluate(validation_generator)
print(f"Accuracy (Validation): {accuracy_val:.4%}")

# Evaluate on test data
loss_test, accuracy_test = model.evaluate(test_generator)
print(f"Accuracy (Test): {accuracy_test:.4%}")

"""## Result Visualization"""

plt.figure(figsize=(12, 4))

# Accuracy
plt.subplot(1, 2, 1)
plt.plot(history.history['accuracy'], label='Train Accuracy')
plt.plot(history.history['val_accuracy'], label='Val Accuracy')
plt.title('Model Accuracy')
plt.xlabel('Epoch')
plt.ylabel('Accuracy')
plt.legend()

# Loss
plt.subplot(1, 2, 2)
plt.plot(history.history['loss'], label='Train Loss')
plt.plot(history.history['val_loss'], label='Val Loss')
plt.title('Model Loss')
plt.xlabel('Epoch')
plt.ylabel('Loss')
plt.legend()

plt.tight_layout()
plt.show()

"""----------------

# InceptionResNetV2 Model

## Model Design
"""

# Set the input image size
IMG_SIZE = (256, 256)

# Load the InceptionResNetV2 model without the top layer
base_model = InceptionResNetV2(include_top=False, weights='imagenet', input_shape=(IMG_SIZE[0], IMG_SIZE[1], 3))

# Freezing the base model layers
base_model.trainable = False

# Create custom layers on top
x = base_model.output
x = GlobalAveragePooling2D()(x)
x = Dense(1024, activation='relu')(x)
x = Dense(3, activation='softmax')(x)

transfer_model = Model(inputs=base_model.input, outputs=x)


transfer_model.summary()

"""## Model Compilation & Training"""

transfer_model.compile(
    optimizer='adam',
    loss='categorical_crossentropy',
    metrics=['accuracy']
)

transfer_history = transfer_model.fit(
    train_generator,
    epochs=10,
    validation_data=validation_generator
)

"""## Model Evaluation"""

# Evaluate on training data
loss_train, accuracy_train = transfer_model.evaluate(train_generator)
print(f"Accuracy (Train): {accuracy_train:.4%}")

# Evaluate on validation data
loss_val, accuracy_val = transfer_model.evaluate(validation_generator)
print(f"Accuracy (Validation): {accuracy_val:.4%}")

# Evaluate on test data
loss_test, accuracy_test = transfer_model.evaluate(test_generator)
print(f"Accuracy (Test): {accuracy_test:.4%}")

"""## Result Visualization"""

plt.figure(figsize=(12, 4))

# Accuracy
plt.subplot(1, 2, 1)
plt.plot(transfer_history.history['accuracy'], label='Train Accuracy')
plt.plot(transfer_history.history['val_accuracy'], label='Val Accuracy')
plt.title('Model Accuracy')
plt.xlabel('Epoch')
plt.ylabel('Accuracy')
plt.legend()

# Loss
plt.subplot(1, 2, 2)
plt.plot(transfer_history.history['loss'], label='Train Loss')
plt.plot(transfer_history.history['val_loss'], label='Val Loss')
plt.title('Model Loss')
plt.xlabel('Epoch')
plt.ylabel('Loss')
plt.legend()

plt.tight_layout()
plt.show()

"""----------------

# Prediction on Random Data
"""

Early_Blight_path = '/kaggle/input/potato-disease-leaf-datasetpld/PLD_3_Classes_256/Testing/Early_Blight/Early_Blight_1.jpg'
Healthy_path = '/kaggle/input/potato-disease-leaf-datasetpld/PLD_3_Classes_256/Testing/Healthy/Healthy_1.jpg'
Late_Blight_path = '/kaggle/input/potato-disease-leaf-datasetpld/PLD_3_Classes_256/Testing/Late_Blight/Late_Blight_2.jpg'

"""## Prediction on early blight"""

# Read the image using imread
Early_Blight_image = mpimg.imread(Early_Blight_path)

# Display the image using imshow
plt.imshow(Early_Blight_image)
plt.show()

from tensorflow.keras.preprocessing import image

# Load and preprocess image
img = image.load_img(Early_Blight_path, target_size=(256, 256))
img_array = image.img_to_array(img)
img_array = np.expand_dims(img_array, axis=0)
img_array = img_array / 255.0

# Predict
prediction = model.predict(img_array)
predicted_class = np.argmax(prediction, axis=1)[0]

# Get class labels from train_generator
class_labels = list(train_generator.class_indices.keys())

# Show image and prediction
plt.imshow(img)
plt.title(f"Predicted: {class_labels[predicted_class]}")
plt.axis('off')
plt.show()

"""## Prediction on Healthy"""

# Read the image using imread
Healthy_image = mpimg.imread(Healthy_path)

# Display the image using imshow
plt.imshow(Healthy_image)
plt.show()

# Load and preprocess image
img = image.load_img(Healthy_path, target_size=(256, 256))
img_array = image.img_to_array(img)
img_array = np.expand_dims(img_array, axis=0)
img_array = img_array / 255.0

# Predict
prediction = model.predict(img_array)
predicted_class = np.argmax(prediction, axis=1)[0]

# Get class labels from train_generator
class_labels = list(train_generator.class_indices.keys())

# Show image and prediction
plt.imshow(img)
plt.title(f"Predicted: {class_labels[predicted_class]}")
plt.axis('off')
plt.show()

"""## Prediction on Late blight"""

# Read the image using imread
Late_Blight_image = mpimg.imread(Late_Blight_path)

# Display the image using imshow
plt.imshow(Late_Blight_image)
plt.show()

# Load and preprocess image
img = image.load_img(Late_Blight_path, target_size=(256, 256))
img_array = image.img_to_array(img)
img_array = np.expand_dims(img_array, axis=0)
img_array = img_array / 255.0

# Predict
prediction = model.predict(img_array)
predicted_class = np.argmax(prediction, axis=1)[0]

# Get class labels from train_generator
class_labels = list(train_generator.class_indices.keys())

# Show image and prediction
plt.imshow(img)
plt.title(f"Predicted: {class_labels[predicted_class]}")
plt.axis('off')
plt.show()